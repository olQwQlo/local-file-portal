<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ローカルファイルポータル（ツリービュー）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --gap: .5rem; }
    body { font-family: system-ui, -apple-system, Segoe UI, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif; line-height: 1.6; margin: 1rem; }
    h1 { margin: 0 0 .25rem; font-size: 1.25rem; }
    .sub { margin: 0 0 1rem; color: #555; }
    #panel { display: grid; gap: .75rem; margin: 0 0 1rem; }
    #genRow { display: grid; gap: .5rem; }
    #codeWrap { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: .5rem; }
    pre {
      background: #2d2d2d; color: #f8f8f2; padding: 10px; border-radius: 6px; overflow-x: auto; margin: 0;
    }
    button, input[type="file"] { font: inherit; }
    #copyBtn { cursor: pointer; padding: 4px 10px; }
    #bar { display: flex; flex-wrap: wrap; gap: var(--gap); align-items: center; }
    #controls { display: flex; gap: var(--gap); }
    #q { padding: .35rem .5rem; min-width: 16rem; }
    ul { list-style: none; padding-left: .75rem; margin: 0; }
    li { user-select: none; }
    .folder { cursor: pointer; font-weight: 600; position: relative; padding-left: 1rem; line-height: 1.8; }
    .folder::before { content: "▶"; position: absolute; left: 0; top: 0; width: 1rem; display: inline-block; }
    .folder.open::before { content: "▽"; }
    .nested { display: none; margin-left: .5rem; }
    .nested.active { display: block; }
    .file a { text-decoration: none; }
    .file a:hover { text-decoration: underline; }
    .muted { color: #666; font-size: .9em; }
    .hidden { display: none !important; }
  </style>
</head>
<body>

  <h1>ローカルファイルポータル（ツリービュー）</h1>
  <p class="sub">単体HTMLで完結：相対/絶対/UNCパス対応、検索・一括展開つき。</p>

  <section id="panel">
    <div id="genRow">
      <strong>1) パス一覧（filelist.txt）を PowerShell で作成</strong>
      <div id="codeWrap">
        <pre id="codeBlock"><code># ルート（＝index.html を置くフォルダ）で実行し、絶対パスの一覧を出力
Get-ChildItem -Recurse -File `
| Where-Object {
    $_.FullName -notmatch '\\node_modules\\|\\.git\\|dist\\|build\\|out\\|target\\|\\.venv\\|\\.m2\\|\\.gradle' -and
    $_.Name -notmatch '^(~\$.*|.*\.(tmp|bak|obj|class|pyc))$'
} `
| Select-Object -ExpandProperty FullName `
| Out-File "$env:USERPROFILE\Downloads\filelist.txt" -Encoding utf8
# 生成された filelist.txt をこのページで読み込み、ツリー表示
</code></pre><br>
        <button id="copyBtn" type="button">コピー</button>
      </div>
    <div>
      <strong>2) filelist.txt を選択（1行1パス）</strong><br>
      <input type="file" id="picker" accept=".txt" />
    </div>
    <!-- ▼ 追加：保存/復元UI -->
    <div id="savedListBar" class="muted" style="margin-top:.5rem; display:flex; gap:.5rem; align-items:center;">
      <button id="useSavedList" type="button" disabled>保存済みのリストを使う</button>
      <button id="clearSavedList" type="button" disabled>保存を削除</button>
      <span id="savedInfo"></span>
    </div>
    <!-- ▲ 追加ここまで -->

    <div id="bar" class="hidden">
      <input id="q" type="search" placeholder="ファイル名を検索（部分一致）">
      <div id="controls">
        <button id="expandAll" type="button">すべて展開</button>
        <button id="collapseAll" type="button">すべて折りたたみ</button>
        <button id="resetView" type="button">初期表示に戻す</button>
      </div>
      <!-- ▼ 選択の保持系 ▼ -->
      <div id="selControls" style="display:flex;gap:.5rem;flex-wrap:wrap;">
        <button id="saveSelection" type="button">選択を保存（local）</button>
        <button id="clearSelection" type="button">選択を全解除</button>
        <button id="exportSelection" type="button">選択をテキストへ書き出し</button>
        <label style="display:inline-flex;gap:.25rem;align-items:center;cursor:pointer;">
          <input id="importSelection" type="file" accept=".txt" style="display:none;">
          <span style="border:1px solid #ccc;padding:.25rem .5rem;border-radius:4px;">選択を読み込み（.txt）</span>
        </label>
      </div>
      <!-- ▲ 選択の保持系 ▲ -->

      <span id="stats" class="muted"></span>
    </div>
  </section>

  <div id="tree" aria-label="ファイルツリー" role="tree"></div>

  <script>
    // --- ヘッダ操作（コピー） ---
    const copyBtn = document.getElementById('copyBtn');
    const codeBlock = document.getElementById('codeBlock').innerText.trim();
    copyBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(codeBlock);
        copyBtn.textContent = "コピーしました！";
        setTimeout(() => copyBtn.textContent = "コピー", 2000);
      } catch (err) {
        alert("コピーに失敗しました: " + err);
      }
    });
    // ▼ ツールバーの要素参照
    const saveSelectionBtn   = document.getElementById('saveSelection');
    const clearSelectionBtn  = document.getElementById('clearSelection');
    const exportSelectionBtn = document.getElementById('exportSelection');
    const importSelectionInp = document.getElementById('importSelection');

    // ▼ ハンドラ
    saveSelectionBtn.onclick = () => {
      const set = new Set(getSelectionArray());
      saveCheckedSet(set);
    };

    clearSelectionBtn.onclick = () => clearAllSelection();

    exportSelectionBtn.onclick = () => exportChecked();

    importSelectionInp.onchange = (e) => {
      const f = e.target.files?.[0];
      if (f) importChecked(f).finally(() => { importSelectionInp.value = ''; });
    };


    // --- 要素参照 ---
    const picker = document.getElementById('picker');
    const bar = document.getElementById('bar');
    const q = document.getElementById('q');
    const expandAllBtn = document.getElementById('expandAll');
    const collapseAllBtn = document.getElementById('collapseAll');
    const resetViewBtn = document.getElementById('resetView');
    const container = document.getElementById('tree');
    const stats = document.getElementById('stats');

    // --- 保存用キー
    const SAVED_LIST_KEY = 'lfp_saved_filelist_v1';
    const SAVED_META_KEY = 'lfp_saved_filelist_meta_v1';

    // 保存
    function saveListText(text) {
      try {
        localStorage.setItem(SAVED_LIST_KEY, text);
        const meta = { savedAt: new Date().toISOString(), lines: text.split(/\r\n|\r|\n/).filter(Boolean).length };
        localStorage.setItem(SAVED_META_KEY, JSON.stringify(meta));
        refreshSavedListUI();
      } catch (e) {
        alert('保存に失敗しました（容量上限の可能性）');
      }
    }

    // 取得
    function getSavedListText() {
      return localStorage.getItem(SAVED_LIST_KEY) || '';
    }

    // 削除
    function clearSavedList() {
      localStorage.removeItem(SAVED_LIST_KEY);
      localStorage.removeItem(SAVED_META_KEY);
      refreshSavedListUI();
    }

    // UI更新
    function refreshSavedListUI() {
      const txt = getSavedListText();
      const useBtn = document.getElementById('useSavedList');
      const clrBtn = document.getElementById('clearSavedList');
      const info   = document.getElementById('savedInfo');
      const metaRaw = localStorage.getItem(SAVED_META_KEY);
      const meta = metaRaw ? JSON.parse(metaRaw) : null;

      const has = !!txt;
      useBtn.disabled = !has;
      clrBtn.disabled = !has;
      info.textContent = has && meta ? `（保存済み: ${new Date(meta.savedAt).toLocaleString()} / ${meta.lines} 行）` : '';
    }


    // --- ツリーモデル判定 ---
    function isFolderNode(node) {
      if (!node || typeof node !== 'object') return false;
      return Object.keys(node).some(k => k !== '__file' && k !== '__full');
    }
    function isFileNode(node) {
      return node && node.__file === true;
    }

    // --- file:// URL 化（UNC/絶対/相対） ---
    function toFileURL(full) {
      if (/^\\\\/.test(full)) {
        // UNC -> file:////server/share/path
        return 'file:////' + full.replace(/^\\\\/, '').replace(/\\/g, '/');
      }
      if (/^[a-zA-Z]:[\\/]/.test(full)) {
        // 絶対 C:\ -> file:///C:/...
        return 'file:///' + full.replace(/\\/g, '/');
      }
      // 相対はそのまま
      return full;
    }

    // --- ツリー構築 ---
    function buildTree(items) {
      const root = {};
      let count = 0;

      for (const raw of items) {
        // raw は { rel: 'kibunyaProject/…', full: 'D:\...\kibunyaProject\…' }
        let rel, full;
        if (typeof raw === 'string') {
          // 後方互換（文字列が来た場合）
          full = raw.replace(/^\uFEFF/, '').trim();
          rel  = full.replace(/\\/g, '/');     // / 区切りへ
        } else {
          full = String(raw.full || '').replace(/^\uFEFF/, '').trim();
          rel  = String(raw.rel  || '').trim(); // すでに / 区切り
        }
        if (!full || !rel) continue;

        const parts = rel.split('/').filter(Boolean); // ← / 固定で分割
        let cur = root;
        for (let i = 0; i < parts.length; i++) {
          const part = parts[i];
          const isLast = i === parts.length - 1;
          cur[part] = cur[part] || {};
          cur = cur[part];
          if (isLast) {
            cur.__file = true;
            cur.__full = full; // リンク用に元の絶対パスを保持
            count++;
          }
        }
      }
      return { root, count };
    }


    // --- DOMパーツ ---
    function createFileLi(name, node) {
      const li = document.createElement('li');
      li.className = 'file';
      li.setAttribute('role', 'treeitem');
      li.setAttribute('aria-selected', 'false');

      const a = document.createElement('a');
      a.textContent = name;
      a.target = '_blank';
      a.rel = 'noopener';
      a.href = encodeURI(toFileURL(node.__full || name));

      // クリックが伝播して親の折りたたみが動くのを防止 
      a.addEventListener('click', (e) => e.stopPropagation());

      li.appendChild(a);
      attachCheckbox(li, node.__full || name);
      return li;
    }

    function createFolderLi(name, node) {
      const li = document.createElement('li');
      li.className = 'folder';
      li.setAttribute('role', 'treeitem');
      li.setAttribute('aria-expanded', 'false');
      li.textContent = name;

      const child = document.createElement('ul');
      child.className = 'nested';
      child.setAttribute('role', 'group');
      li.appendChild(child);

      let built = false;
      li.addEventListener('click', (ev) => {

        // input/label/button/a をクリックしたときは無視
        if (ev.target.closest('input, label, button, a')) return;

        ev.stopPropagation();
        if (!built) {
          buildChildren(child, node);
          built = true;
        }
        const open = !li.classList.contains('open');
        li.classList.toggle('open', open);
        child.classList.toggle('active', open);
        li.setAttribute('aria-expanded', String(open));
      });

      return li;
    }

    function buildChildren(ul, node) {
      const keys = Object.keys(node)
        .filter(k => k !== '__file' && k !== '__full')
        .sort((a, b) => {
          const aIsFolder = isFolderNode(node[a]) && !isFileNode(node[a]);
          const bIsFolder = isFolderNode(node[b]) && !isFileNode(node[b]);
          if (aIsFolder !== bIsFolder) return aIsFolder ? -1 : 1;
          return a.localeCompare(b, 'ja');
        });

      for (const name of keys) {
        const childNode = node[name];
        const hasFolderChildren = isFolderNode(childNode) && !isFileNode(childNode);
        if (hasFolderChildren) {
          ul.appendChild(createFolderLi(name, childNode));
        } else {
          ul.appendChild(createFileLi(name, childNode));
        }
      }
    }

    function renderRoot(treeObj) {
      container.innerHTML = '';
      const ul = document.createElement('ul');
      ul.setAttribute('role', 'tree');
      buildChildren(ul, treeObj);
      container.appendChild(ul);
    }

    // --- 展開/折りたたみ ---
    function expandCollapseAll(expand = true, depth = Infinity) {
      const rootUL = container.querySelector(':scope > ul'); // ★ 追加：正しい起点
      if (!rootUL) return;

      const walk = (el, d) => {
        if (!el || d > depth) return;
        el.querySelectorAll(':scope > li.folder').forEach(li => {
          const nested = li.querySelector(':scope > .nested');
          // 子未構築なら一度クリックして構築
          if (nested && nested.children.length === 0) {
            li.dispatchEvent(new Event('click', { bubbles: false }));
            if (!expand) {
              li.classList.remove('open');
              nested.classList.remove('active');
              li.setAttribute('aria-expanded', 'false');
            }
          } else {
            li.classList.toggle('open', expand);
            nested && nested.classList.toggle('active', expand);
            li.setAttribute('aria-expanded', String(expand));
          }
          if (nested) walk(nested, d + 1);
        });
      };

      walk(rootUL, 1); // ★ ここも rootUL を渡す
    }


    function resetInitialView() {
      // 深さ2まで展開（第一階層＋その子）
      expandCollapseAll(true, 2);
      q.value = '';
      // 全表示
      container.querySelectorAll('li').forEach(li => li.classList.remove('hidden'));
      updateStats();
    }

    // --- 検索（部分一致・簡易） ---
    function anyVisible(el) {
      return [...el.children].some(ch => ch.classList && !ch.classList.contains('hidden'));
    }

    function applyFilter(term) {
      const hasTerm = term.length > 0;
      if (hasTerm) {
        // 全展開で見通し良く
        expandCollapseAll(true, Infinity);
      } else {
        // いったん全表示
        container.querySelectorAll('li').forEach(li => li.classList.remove('hidden'));
        // 初期の深さに戻す
        resetInitialView();
        return;
      }

      term = term.toLowerCase();

      // ファイルの表示/非表示
      container.querySelectorAll('li.file').forEach(li => {
        const name = li.textContent.toLowerCase();
        li.classList.toggle('hidden', !name.includes(term));
      });

      // フォルダは、配下に可視アイテムがあるかで出し分け
      // 深い階層から上へ順に処理
      const folders = Array.from(container.querySelectorAll('li.folder')).reverse();
      folders.forEach(f => {
        const nested = f.querySelector(':scope > .nested');
        if (!nested) return;
        const visible = anyVisible(nested);
        f.classList.toggle('hidden', !visible);
      });

      updateStats();
    }

    // --- 共通プレフィックスを探す ---
    function getCommonPrefix(paths) {
      if (paths.length === 0) return '';
      const splitPaths = paths.map(p => p.split(/[\\/]/));
      const minLen = Math.min(...splitPaths.map(parts => parts.length));
      let prefixParts = [];
      for (let i = 0; i < minLen; i++) {
        const part = splitPaths[0][i];
        if (splitPaths.every(parts => parts[i] === part)) {
          prefixParts.push(part);
        } else {
          break;
        }
      }
      return prefixParts.join('/');
    }
    // ★ filelistテキスト → ツリー描画（共通ルート省略＆明示まで）
    function renderFromText(text) {
      const origLines = text.split(/\r\n|\r|\n/).map(s => s.trim()).filter(Boolean);
      if (origLines.length === 0) return;

      const normLines = origLines.map(l => l.replace(/\\/g, '/'));
      const commonRoot = getCommonPrefix(normLines);

      const items = normLines.map((norm, i) => {
        const rel = norm.startsWith(commonRoot)
          ? norm.slice(commonRoot.length).replace(/^\/+/, '')
          : norm;
        return { rel, full: origLines[i] };
      });

      const { root, count } = buildTree(items);
      renderRoot(root);

      // 明示
      const rootNotice = document.createElement('div');
      rootNotice.className = "muted";
      rootNotice.textContent = `ここから下を表示しています: ${commonRoot}`;
      container.prepend(rootNotice);

      bar.classList.remove('hidden');
      resetInitialView();
      stats.textContent = `${count.toLocaleString()} files`;
    }


    // --- 件数表示 ---
    function updateStats() {
      const total   = container.querySelectorAll('li.file').length;
      const visible = container.querySelectorAll('li.file:not(.hidden)').length;
      const checked = container.querySelectorAll('li.file input[type=checkbox]:checked').length;
      stats.textContent = `${visible.toLocaleString()} / ${total.toLocaleString()} files  ·  selected ${checked}`;
    }


    // --- イベント ---
    picker.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const text = await file.text();

      // 自動保存
      saveListText(text);

      // 描画
      renderFromText(text);
    });



    expandAllBtn.onclick = () => expandCollapseAll(true, Infinity);
    collapseAllBtn.onclick = () => expandCollapseAll(false, Infinity);
    resetViewBtn.onclick = () => resetInitialView();

    q.addEventListener('input', () => applyFilter(q.value.trim()));

    /* ====== 選択（チェック）を保存・読み書きする仕組み ====== */
    const STORAGE_KEY = 'lfp_checked_paths_v1';

    function getCheckedSet() {
      const raw = localStorage.getItem(STORAGE_KEY);
      return new Set(raw ? JSON.parse(raw) : []);
    }
    function saveCheckedSet(set) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify([...set]));
    }
    function getSelectionArray() {
      return [...container.querySelectorAll('li.file input[type=checkbox]:checked')]
            .map(cb => cb.dataset.full);
    }
    function applySelectionFromSet(selSet) {
      container.querySelectorAll('li.file input[type=checkbox]').forEach(cb => {
        cb.checked = selSet.has(cb.dataset.full);
      });
    }

    const useSavedBtn = document.getElementById('useSavedList');
    const clearSavedBtn = document.getElementById('clearSavedList');

    useSavedBtn.onclick = () => {
      const txt = getSavedListText();
      if (!txt) return;
      renderFromText(txt);
    };

    clearSavedBtn.onclick = () => {
      if (confirm('保存済みのリストを削除しますか？')) {
        clearSavedList();
      }
    };

    /* ファイル行にチェックボックスを付与 */
    function attachCheckbox(li, fullPath) {
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.title = '重要（選択リスト）';
      cb.dataset.full = fullPath;

      // クリックが伝播してリンクが開くのを防止
      cb.addEventListener('click', (e) => e.stopPropagation());


      // localStorageの選択状態を反映
      const sel = getCheckedSet();
      cb.checked = sel.has(fullPath);

      cb.addEventListener('change', () => {
        const s = getCheckedSet();
        cb.checked ? s.add(fullPath) : s.delete(fullPath);
        saveCheckedSet(s);
        updateStats();
      });

      // 見た目：行頭に配置
      li.prepend(cb);
    }

    /* 書き出し（③エクスポート） */
    function exportChecked(filename = 'checked-list.txt') {
      const lines = getSelectionArray().join('\n');
      const blob = new Blob([lines], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = Object.assign(document.createElement('a'), { href: url, download: filename });
      a.click();
      URL.revokeObjectURL(url);
    }

    /* 読み込み（③インポート） */
    async function importChecked(file) {
      const text = await file.text();
      const set = new Set(text.split(/\r?\n/).map(s => s.trim()).filter(Boolean));
      applySelectionFromSet(set);
      saveCheckedSet(set);   // localStorageにも同期（①）
      updateStats();
    }

    /* 全解除 */
    function clearAllSelection() {
      const set = new Set();
      applySelectionFromSet(set);
      saveCheckedSet(set);
      updateStats();
    }
    // ページ読込時
    refreshSavedListUI();
  </script>

</body>
</html>
