<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ローカルファイルポータル（ツリービュー）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { 
      --gap: .5rem; 
      --primary-bg: #2d2d2d;
      --primary-text: #f8f8f2;
      --muted-color: #666;
      --border-color: #ccc;
    }
    
    body { 
      font-family: system-ui, -apple-system, Segoe UI, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif; 
      line-height: 1.6; 
      margin: 1rem; 
    }
    
    h1 { 
      margin: 0 0 .25rem; 
      font-size: 1.25rem; 
    }
    
    .sub { 
      margin: 0 0 1rem; 
      color: #555; 
    }
    
    #panel { 
      display: grid; 
      gap: .75rem; 
      margin: 0 0 1rem; 
    }
    
    #genRow { 
      display: grid; 
      gap: .5rem; 
    }
    
    #codeWrap { 
      display: grid; 
      grid-template-columns: 1fr auto; 
      align-items: center; 
      gap: .5rem; 
    }
    
    pre {
      background: var(--primary-bg); 
      color: var(--primary-text); 
      padding: 10px; 
      border-radius: 6px; 
      overflow-x: auto; 
      margin: 0;
    }
    
    button, input[type="file"] { 
      font: inherit; 
    }
    
    #copyBtn { 
      cursor: pointer; 
      padding: 4px 10px; 
    }
    
    #bar { 
      display: flex; 
      flex-wrap: wrap; 
      gap: var(--gap); 
      align-items: center; 
    }
    
    #controls { 
      display: flex; 
      gap: var(--gap); 
    }
    
    #q { 
      padding: .35rem .5rem; 
      min-width: 16rem; 
    }
    
    ul { 
      list-style: none; 
      padding-left: .75rem; 
      margin: 0; 
    }
    
    li { 
      user-select: text; 
    }
    
    .folder { 
      cursor: pointer; 
      font-weight: 600; 
      position: relative; 
      padding-left: 1rem; 
      line-height: 1.8; 
    }
    
    .folder::before { 
      content: "▶"; 
      position: absolute; 
      left: 0; 
      top: 0; 
      width: 1rem; 
      display: inline-block; 
    }
    
    .folder.open::before { 
      content: "▽"; 
    }
    
    .nested { 
      display: none; 
      margin-left: .5rem; 
    }
    
    .nested.active { 
      display: block; 
    }
    
    .file a { 
      text-decoration: none; 
    }
    
    .file a:hover { 
      text-decoration: underline; 
    }
    
    .muted { 
      color: var(--muted-color); 
      font-size: .9em; 
    }
    
    .hidden { 
      display: none !important; 
    }
    
    .indent {
      white-space: pre;
      font-size: 0;
    }
    
    #selControls {
      display: flex;
      gap: .5rem;
      flex-wrap: wrap;
    }
    
    #savedListBar {
      margin-top: .5rem;
      display: flex;
      gap: .5rem;
      align-items: center;
    }
  </style>
</head>
<body>

  <h1>ローカルファイルポータル（ツリービュー）</h1>
  <p class="sub">単体HTMLで完結：相対/絶対/UNCパス対応、検索・一括展開つき。</p>

  <section id="panel">
    <div id="genRow">
      <strong>1) パス一覧（filelist.txt）を PowerShell で作成</strong>
      <div id="codeWrap">
        <pre id="codeBlock"><code># ルート（＝index.html を置くフォルダ）で実行し、絶対パスの一覧を出力
Get-ChildItem -Recurse -File `
| Where-Object {
    $_.FullName -notmatch '\\node_modules\\|\\.git\\|dist\\|build\\|out\\|target\\|\\.venv\\|\\.m2\\|\\.gradle' -and
    $_.Name -notmatch '^(~\$.*|.*\.(tmp|bak|obj|class|pyc))$'
} `
| Select-Object -ExpandProperty FullName `
| Out-File "$env:USERPROFILE\Downloads\filelist.txt" -Encoding utf8
# 生成された filelist.txt をこのページで読み込み、ツリー表示
</code></pre><br>
        <button id="copyBtn" type="button">コピー</button>
      </div>
    <div>
      <strong>2) filelist.txt を選択（1行1パス）</strong><br>
      <input type="file" id="picker" accept=".txt" />
    </div>
    
    <div id="savedListBar" class="muted">
      <button id="useSavedList" type="button" disabled>保存済みのリストを使う</button>
      <button id="clearSavedList" type="button" disabled>保存を削除</button>
      <span id="savedInfo"></span>
    </div>

    <div id="bar" class="hidden">
      <input id="q" type="search" placeholder="ファイル名を検索（部分一致）">
      <div id="controls">
        <button id="expandAll" type="button">すべて展開</button>
        <button id="collapseAll" type="button">すべて折りたたみ</button>
        <button id="resetView" type="button">初期表示に戻す</button>
      </div>
      
      <div id="selControls">
        <button id="saveSelection" type="button">選択を保存（local）</button>
        <button id="clearSelection" type="button">選択を全解除</button>
        <button id="exportSelection" type="button">選択をテキストへ書き出し</button>
        <label style="display:inline-flex;gap:.25rem;align-items:center;cursor:pointer;">
          <input id="importSelection" type="file" accept=".txt" style="display:none;">
          <span style="border:1px solid var(--border-color);padding:.25rem .5rem;border-radius:4px;">選択を読み込み（.txt）</span>
        </label>
      </div>

      <span id="stats" class="muted"></span>
    </div>
  </section>

  <div id="tree" aria-label="ファイルツリー" role="tree"></div>

  <script>
    /**
     * ローカルファイルポータル - メインクラス
     * ファイル一覧をツリー表示し、検索・選択機能を提供する
     */
    class LocalFilePortal {
      constructor() {
        this.initConstants();
        this.initElements();
        this.initEventHandlers();
        this.refreshSavedListUI();
      }

      /**
       * 定数の初期化
       */
      initConstants() {
        this.STORAGE_KEYS = {
          SAVED_LIST: 'lfp_saved_filelist_v1',
          SAVED_META: 'lfp_saved_filelist_meta_v1',
          CHECKED_PATHS: 'lfp_checked_paths_v1'
        };
      }

      /**
       * DOM要素の参照を初期化
       */
      initElements() {
        // ヘッダー要素
        this.copyBtn = document.getElementById('copyBtn');
        this.codeBlock = document.getElementById('codeBlock').innerText.trim();
        
        // ファイル選択
        this.picker = document.getElementById('picker');
        
        // 保存機能
        this.useSavedBtn = document.getElementById('useSavedList');
        this.clearSavedBtn = document.getElementById('clearSavedList');
        this.savedInfo = document.getElementById('savedInfo');
        
        // ツールバー
        this.bar = document.getElementById('bar');
        this.searchInput = document.getElementById('q');
        this.expandAllBtn = document.getElementById('expandAll');
        this.collapseAllBtn = document.getElementById('collapseAll');
        this.resetViewBtn = document.getElementById('resetView');
        
        // 選択機能
        this.saveSelectionBtn = document.getElementById('saveSelection');
        this.clearSelectionBtn = document.getElementById('clearSelection');
        this.exportSelectionBtn = document.getElementById('exportSelection');
        this.importSelectionInp = document.getElementById('importSelection');
        
        // ツリー表示
        this.container = document.getElementById('tree');
        this.stats = document.getElementById('stats');
      }

      /**
       * イベントハンドラーの初期化
       */
      initEventHandlers() {
        // ヘッダー操作
        this.copyBtn.addEventListener('click', () => this.copyCode());
        
        // ファイル選択
        this.picker.addEventListener('change', (e) => this.handleFileSelect(e));
        
        // 保存機能
        this.useSavedBtn.onclick = () => this.useSavedList();
        this.clearSavedBtn.onclick = () => this.clearSavedList();
        
        // ツリー操作
        this.expandAllBtn.onclick = () => this.expandCollapseAll(true);
        this.collapseAllBtn.onclick = () => this.expandCollapseAll(false);
        this.resetViewBtn.onclick = () => this.resetInitialView();
        this.searchInput.addEventListener('input', () => this.applyFilter(this.searchInput.value.trim()));
        
        // 選択機能
        this.saveSelectionBtn.onclick = () => this.saveSelection();
        this.clearSelectionBtn.onclick = () => this.clearAllSelection();
        this.exportSelectionBtn.onclick = () => this.exportSelection();
        this.importSelectionInp.onchange = (e) => this.importSelection(e);
      }

      /**
       * PowerShellコードをクリップボードにコピー
       */
      async copyCode() {
        try {
          await navigator.clipboard.writeText(this.codeBlock);
          this.copyBtn.textContent = "コピーしました！";
          setTimeout(() => this.copyBtn.textContent = "コピー", 2000);
        } catch (err) {
          alert("コピーに失敗しました: " + err);
        }
      }

      /**
       * ファイル選択時の処理
       */
      async handleFileSelect(event) {
        const file = event.target.files?.[0];
        if (!file) return;
        
        try {
          const text = await file.text();
          this.saveListText(text);
          this.renderFromText(text);
        } catch (error) {
          alert("ファイル読み込みエラー: " + error.message);
        }
      }

      /**
       * リストテキストを保存
       */
      saveListText(text) {
        try {
          localStorage.setItem(this.STORAGE_KEYS.SAVED_LIST, text);
          const meta = { 
            savedAt: new Date().toISOString(), 
            lines: text.split(/\r\n|\r|\n/).filter(Boolean).length 
          };
          localStorage.setItem(this.STORAGE_KEYS.SAVED_META, JSON.stringify(meta));
          this.refreshSavedListUI();
        } catch (e) {
          alert('保存に失敗しました（容量上限の可能性）');
        }
      }

      /**
       * 保存済みリストを取得
       */
      getSavedListText() {
        return localStorage.getItem(this.STORAGE_KEYS.SAVED_LIST) || '';
      }

      /**
       * 保存済みリストを使用
       */
      useSavedList() {
        const text = this.getSavedListText();
        if (!text) return;
        this.renderFromText(text);
      }

      /**
       * 保存済みリストを削除
       */
      clearSavedList() {
        if (!confirm('保存済みのリストを削除しますか？')) return;
        
        localStorage.removeItem(this.STORAGE_KEYS.SAVED_LIST);
        localStorage.removeItem(this.STORAGE_KEYS.SAVED_META);
        this.refreshSavedListUI();
      }

      /**
       * 保存済みリストのUI更新
       */
      refreshSavedListUI() {
        const text = this.getSavedListText();
        const metaRaw = localStorage.getItem(this.STORAGE_KEYS.SAVED_META);
        const meta = metaRaw ? JSON.parse(metaRaw) : null;
        
        const hasData = !!text;
        this.useSavedBtn.disabled = !hasData;
        this.clearSavedBtn.disabled = !hasData;
        
        this.savedInfo.textContent = hasData && meta 
          ? `（保存済み: ${new Date(meta.savedAt).toLocaleString()} / ${meta.lines} 行）` 
          : '';
      }

      /**
       * テキストからツリーを描画
       */
      renderFromText(text) {
        const origLines = text.split(/\r\n|\r|\n/)
          .map(line => line.trim())
          .filter(Boolean);
        
        if (origLines.length === 0) return;

        const treeData = this.buildTreeFromLines(origLines);
        this.renderTree(treeData);
        
        this.bar.classList.remove('hidden');
        this.resetInitialView();
        this.updateStats();
      }

      /**
       * 行データからツリー構造を構築
       */
      buildTreeFromLines(lines) {
        const normLines = lines.map(line => line.replace(/\\/g, '/'));
        const commonRoot = this.getCommonPrefix(normLines);

        const items = normLines.map((norm, i) => {
          const rel = norm.startsWith(commonRoot)
            ? norm.slice(commonRoot.length).replace(/^\/+/, '')
            : norm;
          return { rel, full: lines[i] };
        });

        const { root, count } = this.buildTree(items);
        
        return { root, count, commonRoot };
      }

      /**
       * 共通プレフィックスを取得
       */
      getCommonPrefix(paths) {
        if (paths.length === 0) return '';
        
        const splitPaths = paths.map(p => p.split(/[\\/]/));
        const minLen = Math.min(...splitPaths.map(parts => parts.length));
        const prefixParts = [];
        
        for (let i = 0; i < minLen; i++) {
          const part = splitPaths[0][i];
          if (splitPaths.every(parts => parts[i] === part)) {
            prefixParts.push(part);
          } else {
            break;
          }
        }
        
        return prefixParts.join('/');
      }

      /**
       * ツリー構造を構築
       */
      buildTree(items) {
        const root = {};
        let count = 0;

        for (const item of items) {
          const { rel, full } = item;
          if (!full || !rel) continue;

          const parts = rel.split('/').filter(Boolean);
          let current = root;
          
          for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            const isLast = i === parts.length - 1;
            
            current[part] = current[part] || {};
            current = current[part];
            
            if (isLast) {
              current.__file = true;
              current.__full = full;
              count++;
            }
          }
        }
        
        return { root, count };
      }

      /**
       * ツリーをDOMに描画
       */
      renderTree({ root, count, commonRoot }) {
        this.container.innerHTML = '';
        
        // 共通ルート情報を表示
        if (commonRoot) {
          const notice = document.createElement('div');
          notice.className = "muted";
          notice.textContent = `ここから下を表示しています: ${commonRoot}`;
          this.container.appendChild(notice);
        }
        
        const ul = document.createElement('ul');
        ul.setAttribute('role', 'tree');
        this.buildChildren(ul, root);
        this.container.appendChild(ul);
        
        this.stats.textContent = `${count.toLocaleString()} files`;
      }

      /**
       * 子要素を構築
       */
      buildChildren(ul, node, depth = 0) {
        const keys = Object.keys(node)
          .filter(key => key !== '__file' && key !== '__full')
          .sort((a, b) => {
            const aIsFolder = this.isFolderNode(node[a]) && !this.isFileNode(node[a]);
            const bIsFolder = this.isFolderNode(node[b]) && !this.isFileNode(node[b]);
            if (aIsFolder !== bIsFolder) return aIsFolder ? -1 : 1;
            return a.localeCompare(b, 'ja');
          });

        for (const name of keys) {
          const childNode = node[name];
          const isFolder = this.isFolderNode(childNode) && !this.isFileNode(childNode);
          
          const li = isFolder 
            ? this.createFolderElement(name, childNode) 
            : this.createFileElement(name, childNode);

          // インデント追加
          this.addIndent(li, depth);
          ul.appendChild(li);

          if (isFolder) {
            const nested = li.querySelector(':scope > .nested');
            this.buildChildren(nested, childNode, depth + 1);
          }
        }
      }

      /**
       * フォルダ要素を作成
       */
      createFolderElement(name, node) {
        const li = document.createElement('li');
        li.className = 'folder';
        li.setAttribute('role', 'treeitem');
        li.setAttribute('aria-expanded', 'false');
        li.textContent = name;

        const nested = document.createElement('ul');
        nested.className = 'nested';
        nested.setAttribute('role', 'group');
        li.appendChild(nested);

        let built = false;
        li.addEventListener('click', (event) => {
          if (event.target.closest('input, label, button, a')) return;
          
          // テキスト選択中は開閉しない
          const selection = window.getSelection && window.getSelection();
          if (selection && !selection.isCollapsed) return;

          event.stopPropagation();
          
          if (!built) {
            this.buildChildren(nested, node);
            built = true;
          }
          
          const isOpen = !li.classList.contains('open');
          li.classList.toggle('open', isOpen);
          nested.classList.toggle('active', isOpen);
          li.setAttribute('aria-expanded', String(isOpen));
        });

        return li;
      }

      /**
       * ファイル要素を作成
       */
      createFileElement(name, node) {
        const li = document.createElement('li');
        li.className = 'file';
        li.setAttribute('role', 'treeitem');
        li.setAttribute('aria-selected', 'false');

        const link = document.createElement('a');
        link.textContent = name;
        link.target = '_blank';
        link.rel = 'noopener';
        link.href = encodeURI(this.toFileURL(node.__full || name));
        
        link.addEventListener('click', (e) => e.stopPropagation());
        
        li.appendChild(link);
        this.attachCheckbox(li, node.__full || name);
        
        return li;
      }

      /**
       * インデントを追加
       */
      addIndent(element, depth) {
        const indentSpan = document.createElement('span');
        indentSpan.className = 'indent';
        indentSpan.textContent = '  '.repeat(depth);
        element.insertBefore(indentSpan, element.firstChild);
      }

      /**
       * チェックボックスを追加
       */
      attachCheckbox(li, fullPath) {
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.title = '重要（選択リスト）';
        checkbox.dataset.full = fullPath;
        
        checkbox.addEventListener('click', (e) => e.stopPropagation());
        
        // 保存済み選択状態を反映
        const savedSelection = this.getCheckedSet();
        checkbox.checked = savedSelection.has(fullPath);
        
        checkbox.addEventListener('change', () => {
          const selection = this.getCheckedSet();
          checkbox.checked ? selection.add(fullPath) : selection.delete(fullPath);
          this.saveCheckedSet(selection);
          this.updateStats();
        });
        
        li.prepend(checkbox);
      }

      /**
       * ファイルURLに変換
       */
      toFileURL(path) {
        if (/^\\\\/.test(path)) {
          // UNC パス
          return 'file:////' + path.replace(/^\\\\/, '').replace(/\\/g, '/');
        }
        if (/^[a-zA-Z]:[\\/]/.test(path)) {
          // 絶対パス
          return 'file:///' + path.replace(/\\/g, '/');
        }
        // 相対パス
        return path;
      }

      /**
       * ノードタイプ判定
       */
      isFolderNode(node) {
        if (!node || typeof node !== 'object') return false;
        return Object.keys(node).some(key => key !== '__file' && key !== '__full');
      }

      isFileNode(node) {
        return node && node.__file === true;
      }

      /**
       * 全展開・全折りたたみ
       */
      expandCollapseAll(expand = true, maxDepth = Infinity) {
        const rootUL = this.container.querySelector(':scope > ul');
        if (!rootUL) return;

        const processElement = (element, currentDepth) => {
          if (!element || currentDepth > maxDepth) return;
          
          element.querySelectorAll(':scope > li.folder').forEach(folder => {
            const nested = folder.querySelector(':scope > .nested');
            
            // 未構築の場合は一度クリックして構築
            if (nested && nested.children.length === 0) {
              folder.dispatchEvent(new Event('click', { bubbles: false }));
              if (!expand) {
                folder.classList.remove('open');
                nested.classList.remove('active');
                folder.setAttribute('aria-expanded', 'false');
              }
            } else {
              folder.classList.toggle('open', expand);
              nested && nested.classList.toggle('active', expand);
              folder.setAttribute('aria-expanded', String(expand));
            }
            
            if (nested) {
              processElement(nested, currentDepth + 1);
            }
          });
        };

        processElement(rootUL, 1);
      }

      /**
       * 初期表示に戻す
       */
      resetInitialView() {
        this.expandCollapseAll(true, 2); // 深さ2まで展開
        this.searchInput.value = '';
        this.container.querySelectorAll('li').forEach(li => li.classList.remove('hidden'));
        this.updateStats();
      }

      /**
       * フィルターを適用
       */
      applyFilter(term) {
        const hasTerm = term.length > 0;
        
        if (hasTerm) {
          this.expandCollapseAll(true); // 全展開
          this.filterByTerm(term.toLowerCase());
        } else {
          this.container.querySelectorAll('li').forEach(li => li.classList.remove('hidden'));
          this.resetInitialView();
          return;
        }
        
        this.updateStats();
      }

      /**
       * 検索語でフィルタリング
       */
      filterByTerm(term) {
        // ファイルのフィルタリング
        this.container.querySelectorAll('li.file').forEach(li => {
          const name = li.textContent.toLowerCase();
          li.classList.toggle('hidden', !name.includes(term));
        });

        // フォルダのフィルタリング（子要素に表示可能なものがあるか）
        const folders = Array.from(this.container.querySelectorAll('li.folder')).reverse();
        folders.forEach(folder => {
          const nested = folder.querySelector(':scope > .nested');
          if (!nested) return;
          
          const hasVisibleChildren = this.hasVisibleChildren(nested);
          folder.classList.toggle('hidden', !hasVisibleChildren);
        });
      }

      /**
       * 表示可能な子要素があるかチェック
       */
      hasVisibleChildren(element) {
        return [...element.children].some(child => 
          child.classList && !child.classList.contains('hidden')
        );
      }

      /**
       * 統計情報を更新
       */
      updateStats() {
        const total = this.container.querySelectorAll('li.file').length;
        const visible = this.container.querySelectorAll('li.file:not(.hidden)').length;
        const checked = this.container.querySelectorAll('li.file input[type=checkbox]:checked').length;
        
        this.stats.textContent = `${visible.toLocaleString()} / ${total.toLocaleString()} files  ·  selected ${checked}`;
      }

      /**
       * 選択機能
       */
      getCheckedSet() {
        const raw = localStorage.getItem(this.STORAGE_KEYS.CHECKED_PATHS);
        return new Set(raw ? JSON.parse(raw) : []);
      }

      saveCheckedSet(set) {
        localStorage.setItem(this.STORAGE_KEYS.CHECKED_PATHS, JSON.stringify([...set]));
      }

      getSelectionArray() {
        return [...this.container.querySelectorAll('li.file input[type=checkbox]:checked')]
          .map(checkbox => checkbox.dataset.full);
      }

      applySelectionFromSet(selectionSet) {
        this.container.querySelectorAll('li.file input[type=checkbox]').forEach(checkbox => {
          checkbox.checked = selectionSet.has(checkbox.dataset.full);
        });
      }

      saveSelection() {
        const selection = new Set(this.getSelectionArray());
        this.saveCheckedSet(selection);
      }

      clearAllSelection() {
        const emptySet = new Set();
        this.applySelectionFromSet(emptySet);
        this.saveCheckedSet(emptySet);
        this.updateStats();
      }

      exportSelection(filename = 'checked-list.txt') {
        const lines = this.getSelectionArray().join('\n');
        const blob = new Blob([lines], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        
        const link = Object.assign(document.createElement('a'), { 
          href: url, 
          download: filename 
        });
        link.click();
        URL.revokeObjectURL(url);
      }

      async importSelection(event) {
        const file = event.target.files?.[0];
        if (!file) return;
        
        try {
          const text = await file.text();
          const selectionSet = new Set(
            text.split(/\r?\n/)
              .map(line => line.trim())
              .filter(Boolean)
          );
          
          this.applySelectionFromSet(selectionSet);
          this.saveCheckedSet(selectionSet);
          this.updateStats();
        } catch (error) {
          alert('選択の読み込みに失敗しました: ' + error.message);
        } finally {
          this.importSelectionInp.value = '';
        }
      }
    }

    // アプリケーション初期化
    document.addEventListener('DOMContentLoaded', () => {
      new LocalFilePortal();
    });
  </script>

</body>
</html>